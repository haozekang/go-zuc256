package zuc256

import (
	"fmt"
)

/*
 * 吃水不忘挖井人，在这里感谢GmSSL及BouncyCastle两个强大的密码学库！
 * 本ZUC256的编写，参考了这两个库及中科院软件院发布的祖冲之算法白皮书而实现的。
 * 其中IV的长度有歧义，我这里做了兼容并包的处理方式，IV为23位时，使用的是GmSSL的逻辑，
 * IV为25位时，使用的是白皮书中给定的长度逻辑。
 * 代码要用的话，直接拿起用，给我GitHub点个小星星就行
 * 本代码有且仅遵守MIT协议！！！
 */

const AlgorithmName = "ZUC256"
const IVSize = 25
const KeySize = 32

var lFSR [16]uint32
var keyStream []uint32
var r1 = uint32(0)
var r2 = uint32(0)

var s0 = []byte{
	0x3e, 0x72, 0x5b, 0x47, 0xca, 0xe0, 0x00, 0x33, 0x04, 0xd1, 0x54, 0x98, 0x09, 0xb9, 0x6d, 0xcb,
	0x7b, 0x1b, 0xf9, 0x32, 0xaf, 0x9d, 0x6a, 0xa5, 0xb8, 0x2d, 0xfc, 0x1d, 0x08, 0x53, 0x03, 0x90,
	0x4d, 0x4e, 0x84, 0x99, 0xe4, 0xce, 0xd9, 0x91, 0xdd, 0xb6, 0x85, 0x48, 0x8b, 0x29, 0x6e, 0xac,
	0xcd, 0xc1, 0xf8, 0x1e, 0x73, 0x43, 0x69, 0xc6, 0xb5, 0xbd, 0xfd, 0x39, 0x63, 0x20, 0xd4, 0x38,
	0x76, 0x7d, 0xb2, 0xa7, 0xcf, 0xed, 0x57, 0xc5, 0xf3, 0x2c, 0xbb, 0x14, 0x21, 0x06, 0x55, 0x9b,
	0xe3, 0xef, 0x5e, 0x31, 0x4f, 0x7f, 0x5a, 0xa4, 0x0d, 0x82, 0x51, 0x49, 0x5f, 0xba, 0x58, 0x1c,
	0x4a, 0x16, 0xd5, 0x17, 0xa8, 0x92, 0x24, 0x1f, 0x8c, 0xff, 0xd8, 0xae, 0x2e, 0x01, 0xd3, 0xad,
	0x3b, 0x4b, 0xda, 0x46, 0xeb, 0xc9, 0xde, 0x9a, 0x8f, 0x87, 0xd7, 0x3a, 0x80, 0x6f, 0x2f, 0xc8,
	0xb1, 0xb4, 0x37, 0xf7, 0x0a, 0x22, 0x13, 0x28, 0x7c, 0xcc, 0x3c, 0x89, 0xc7, 0xc3, 0x96, 0x56,
	0x07, 0xbf, 0x7e, 0xf0, 0x0b, 0x2b, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xa6, 0x4c, 0x10, 0xfe,
	0xbc, 0x26, 0x95, 0x88, 0x8a, 0xb0, 0xa3, 0xfb, 0xc0, 0x18, 0x94, 0xf2, 0xe1, 0xe5, 0xe9, 0x5d,
	0xd0, 0xdc, 0x11, 0x66, 0x64, 0x5c, 0xec, 0x59, 0x42, 0x75, 0x12, 0xf5, 0x74, 0x9c, 0xaa, 0x23,
	0x0e, 0x86, 0xab, 0xbe, 0x2a, 0x02, 0xe7, 0x67, 0xe6, 0x44, 0xa2, 0x6c, 0xc2, 0x93, 0x9f, 0xf1,
	0xf6, 0xfa, 0x36, 0xd2, 0x50, 0x68, 0x9e, 0x62, 0x71, 0x15, 0x3d, 0xd6, 0x40, 0xc4, 0xe2, 0x0f,
	0x8e, 0x83, 0x77, 0x6b, 0x25, 0x05, 0x3f, 0x0c, 0x30, 0xea, 0x70, 0xb7, 0xa1, 0xe8, 0xa9, 0x65,
	0x8d, 0x27, 0x1a, 0xdb, 0x81, 0xb3, 0xa0, 0xf4, 0x45, 0x7a, 0x19, 0xdf, 0xee, 0x78, 0x34, 0x60,
}

var s1 = []byte{
	0x55, 0xc2, 0x63, 0x71, 0x3b, 0xc8, 0x47, 0x86, 0x9f, 0x3c, 0xda, 0x5b, 0x29, 0xaa, 0xfd, 0x77,
	0x8c, 0xc5, 0x94, 0x0c, 0xa6, 0x1a, 0x13, 0x00, 0xe3, 0xa8, 0x16, 0x72, 0x40, 0xf9, 0xf8, 0x42,
	0x44, 0x26, 0x68, 0x96, 0x81, 0xd9, 0x45, 0x3e, 0x10, 0x76, 0xc6, 0xa7, 0x8b, 0x39, 0x43, 0xe1,
	0x3a, 0xb5, 0x56, 0x2a, 0xc0, 0x6d, 0xb3, 0x05, 0x22, 0x66, 0xbf, 0xdc, 0x0b, 0xfa, 0x62, 0x48,
	0xdd, 0x20, 0x11, 0x06, 0x36, 0xc9, 0xc1, 0xcf, 0xf6, 0x27, 0x52, 0xbb, 0x69, 0xf5, 0xd4, 0x87,
	0x7f, 0x84, 0x4c, 0xd2, 0x9c, 0x57, 0xa4, 0xbc, 0x4f, 0x9a, 0xdf, 0xfe, 0xd6, 0x8d, 0x7a, 0xeb,
	0x2b, 0x53, 0xd8, 0x5c, 0xa1, 0x14, 0x17, 0xfb, 0x23, 0xd5, 0x7d, 0x30, 0x67, 0x73, 0x08, 0x09,
	0xee, 0xb7, 0x70, 0x3f, 0x61, 0xb2, 0x19, 0x8e, 0x4e, 0xe5, 0x4b, 0x93, 0x8f, 0x5d, 0xdb, 0xa9,
	0xad, 0xf1, 0xae, 0x2e, 0xcb, 0x0d, 0xfc, 0xf4, 0x2d, 0x46, 0x6e, 0x1d, 0x97, 0xe8, 0xd1, 0xe9,
	0x4d, 0x37, 0xa5, 0x75, 0x5e, 0x83, 0x9e, 0xab, 0x82, 0x9d, 0xb9, 0x1c, 0xe0, 0xcd, 0x49, 0x89,
	0x01, 0xb6, 0xbd, 0x58, 0x24, 0xa2, 0x5f, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xb8, 0x95, 0xe4,
	0xd0, 0x91, 0xc7, 0xce, 0xed, 0x0f, 0xb4, 0x6f, 0xa0, 0xcc, 0xf0, 0x02, 0x4a, 0x79, 0xc3, 0xde,
	0xa3, 0xef, 0xea, 0x51, 0xe6, 0x6b, 0x18, 0xec, 0x1b, 0x2c, 0x80, 0xf7, 0x74, 0xe7, 0xff, 0x21,
	0x5a, 0x6a, 0x54, 0x1e, 0x41, 0x31, 0x92, 0x35, 0xc4, 0x33, 0x07, 0x0a, 0xba, 0x7e, 0x0e, 0x34,
	0x88, 0xb1, 0x98, 0x7c, 0xf3, 0x3d, 0x60, 0x6c, 0x7b, 0xca, 0xd3, 0x1f, 0x32, 0x65, 0x04, 0x28,
	0x64, 0xbe, 0x85, 0x9b, 0x2f, 0x59, 0x8a, 0xd7, 0xb0, 0x25, 0xac, 0xaf, 0x12, 0x03, 0xe2, 0xf2,
}

var zuc256D = [][]byte{
	{0x22, 0x2F, 0x24, 0x2A, 0x6D, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x52, 0x10, 0x30},
	{0x22, 0x2F, 0x25, 0x2A, 0x6D, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x52, 0x10, 0x30},
	{0x23, 0x2F, 0x24, 0x2A, 0x6D, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x52, 0x10, 0x30},
	{0x23, 0x2F, 0x25, 0x2A, 0x6D, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x52, 0x10, 0x30},
}

func Init(key []byte, iv []byte) {
	ivLen := len(iv)
	keyLen := len(key)
	if ivLen == 0 {
		fmt.Printf("%s Init requires an IV.\n", AlgorithmName)
		return
	}
	if keyLen == 0 {
		fmt.Printf("%s Init requires an Key.\n", AlgorithmName)
		return
	}
	if ivLen != 23 && ivLen != 25 {
		fmt.Printf("%s requires exactly 23 or %d bytes of IV.\n", AlgorithmName, IVSize)
		return
	}
	if keyLen != KeySize {
		fmt.Printf("%s requires exactly %d bytes of Key.\n", AlgorithmName, KeySize)
		return
	}
	setKey(key, iv, 0)
}

func setKey(key []byte, iv []byte, macBits int) {
	ivLen := len(iv)
	_r1 := uint32(0)
	_r2 := uint32(0)
	x0 := uint32(0)
	x1 := uint32(0)
	x2 := uint32(0)
	w := uint32(0)
	u := uint32(0)
	v := uint32(0)
	var d []byte

	IV17 := byte(0x00)
	IV18 := byte(0x00)
	IV19 := byte(0x00)
	IV20 := byte(0x00)
	IV21 := byte(0x00)
	IV22 := byte(0x00)
	IV23 := byte(0x00)
	IV24 := byte(0x00)

	if ivLen == 23 {
		IV17 = iv[17] >> 2
		IV18 = ((iv[17] & 0x3) << 4) | (iv[18] >> 4)
		IV19 = ((iv[18] & 0xf) << 2) | (iv[19] >> 6)
		IV20 = iv[19] & 0x3f
		IV21 = iv[20] >> 2
		IV22 = ((iv[20] & 0x3) << 4) | (iv[21] >> 4)
		IV23 = ((iv[21] & 0xf) << 2) | (iv[22] >> 6)
		IV24 = iv[22] & 0x3f
	} else {
		IV17 = iv[17]
		IV18 = iv[18]
		IV19 = iv[19]
		IV20 = iv[20]
		IV21 = iv[21]
		IV22 = iv[22]
		IV23 = iv[23]
		IV24 = iv[24]
	}

	if macBits/32 < 3 {
		d = zuc256D[macBits/32]
	} else {
		d = zuc256D[3]
	}
	lFSR[0] = zuc256MakeU31(uint32(key[0]), uint32(d[0]), uint32(key[21]), uint32(key[16]))
	lFSR[1] = zuc256MakeU31(uint32(key[1]), uint32(d[1]), uint32(key[22]), uint32(key[17]))
	lFSR[2] = zuc256MakeU31(uint32(key[2]), uint32(d[2]), uint32(key[23]), uint32(key[18]))
	lFSR[3] = zuc256MakeU31(uint32(key[3]), uint32(d[3]), uint32(key[24]), uint32(key[19]))
	lFSR[4] = zuc256MakeU31(uint32(key[4]), uint32(d[4]), uint32(key[25]), uint32(key[20]))
	lFSR[5] = zuc256MakeU31(uint32(iv[0]), uint32(d[5]|IV17), uint32(key[5]), uint32(key[26]))
	lFSR[6] = zuc256MakeU31(uint32(iv[1]), uint32(d[6]|IV18), uint32(key[6]), uint32(key[27]))
	lFSR[7] = zuc256MakeU31(uint32(iv[10]), uint32(d[7]|IV19), uint32(key[7]), uint32(iv[2]))
	lFSR[8] = zuc256MakeU31(uint32(key[8]), uint32(d[8]|IV20), uint32(iv[3]), uint32(iv[11]))
	lFSR[9] = zuc256MakeU31(uint32(key[9]), uint32(d[9]|IV21), uint32(iv[12]), uint32(iv[4]))
	lFSR[10] = zuc256MakeU31(uint32(iv[5]), uint32(d[10]|IV22), uint32(key[10]), uint32(key[28]))
	lFSR[11] = zuc256MakeU31(uint32(key[11]), uint32(d[11]|IV23), uint32(iv[6]), uint32(iv[13]))
	lFSR[12] = zuc256MakeU31(uint32(key[12]), uint32(d[12]|IV24), uint32(iv[7]), uint32(iv[14]))
	lFSR[13] = zuc256MakeU31(uint32(key[13]), uint32(d[13]), uint32(iv[15]), uint32(iv[8]))
	lFSR[14] = zuc256MakeU31(uint32(key[14]), uint32(d[14]|(key[31]>>4)), uint32(iv[16]), uint32(iv[9]))
	lFSR[15] = zuc256MakeU31(uint32(key[15]), uint32(d[15]|(key[31]&0x0F)), uint32(key[30]), uint32(key[29]))

	_r1 = 0
	_r2 = 0
	for i := 0; i < 32; i++ {
		bitReconstruction3(lFSR, &x0, &x1, &x2)
		w = f(&_r1, &_r2, &u, &v, x0, x1, x2)
		lFSRWithInitialisationMode(&lFSR, &v, w>>1)
	}

	bitReconstruction2(lFSR, &x1, &x2)
	f_(&_r1, &_r2, &u, &v, x1, x2)
	lFSRWithWorkMode(&lFSR, &v)

	r1 = _r1
	r2 = _r2
}

func lFSRWithWorkMode(lFSR *[16]uint32, v *uint32) {
	a := uint64((*lFSR)[0])
	a += (uint64((*lFSR)[0])) << 8
	a += (uint64((*lFSR)[4])) << 20
	a += (uint64((*lFSR)[10])) << 21
	a += (uint64((*lFSR)[13])) << 17
	a += (uint64((*lFSR)[15])) << 15
	a = (a & 0x7fffffff) + (a >> 31)
	*v = uint32((a & 0x7fffffff) + (a >> 31))
	for j := 0; j < 15; j++ {
		(*lFSR)[j] = (*lFSR)[j+1]
	}
	(*lFSR)[15] = *v
}

func lFSRWithInitialisationMode(lFSR *[16]uint32, v *uint32, u uint32) {
	*v = (*lFSR)[0]
	add31(v, rot31((*lFSR)[0], 8))
	add31(v, rot31((*lFSR)[4], 20))
	add31(v, rot31((*lFSR)[10], 21))
	add31(v, rot31((*lFSR)[13], 17))
	add31(v, rot31((*lFSR)[15], 15))
	add31(v, u)
	for j := 0; j < 15; j++ {
		(*lFSR)[j] = (*lFSR)[j+1]
	}
	(*lFSR)[15] = *v
}

func DoFinal(input []byte) []byte {
	length := len(input)
	var output = make([]byte, length)
	processBytes(input, 0, length, &output)
	return output
}

func processBytes(input []byte, inOff int, _len int, output *[]byte) {
	var block = make([]byte, 4)
	blockLen := len(block)
	inputLen := len(input)
	count := inOff + _len
	generateKeyStream(uint32(count))
	groupCount := count / 4
	i := 0

	for ; i < groupCount; i++ {
		putU32(&block, keyStream[i])
		memXor(output, i, input, block, blockLen)
	}
	if inputLen%4 != 0 {
		putU32(&block, keyStream[i])
		memXor(output, i, input, block, inputLen%4)
	}
}

func generateKeyStream(_len uint32) {
	x0 := uint32(0)
	x1 := uint32(0)
	x2 := uint32(0)
	x3 := uint32(0)
	u := uint32(0)
	v := uint32(0)
	wLen := _len / 4
	if _len%4 != 0 {
		wLen++
	}
	keyStream = make([]uint32, wLen)

	for i := 0; i < int(wLen); i++ {
		bitReconstruction4(lFSR, &x0, &x1, &x2, &x3)
		keyStream[i] = x3 ^ f(&r1, &r2, &u, &v, x0, x1, x2)
		lFSRWithWorkMode(&lFSR, &v)
	}
}

func memXor(_out *[]byte, index int, _in []byte, block []byte, _len int) {
	blockLen := len(block)
	i := index * blockLen
	j := 0
	for i < index*len(block)+_len {
		(*_out)[i] = _in[i] ^ block[j]
		i++
		j++
	}
}

func putU32(block *[]byte, x uint32) {
	(*block)[0] = byte(x >> 24)
	(*block)[1] = byte(x >> 16)
	(*block)[2] = byte(x >> 8)
	(*block)[3] = byte(x)
}

func rot31(a uint32, k int) uint32 {
	return (((a) << (k)) | ((a) >> (31 - (k)))) & 0x7FFFFFFF
}

func add31(a *uint32, b uint32) {
	*a += b
	*a = (*a & 0x7fffffff) + (*a >> 31)
}

func bitReconstruction2(lFSR [16]uint32, x1 *uint32, x2 *uint32) {
	*x1 = ((lFSR[11] & 0xFFFF) << 16) | (lFSR[9] >> 15)
	*x2 = ((lFSR[7] & 0xFFFF) << 16) | (lFSR[5] >> 15)
}

func bitReconstruction3(lFSR [16]uint32, x0 *uint32, x1 *uint32, x2 *uint32) {
	*x0 = ((lFSR[15] & 0x7FFF8000) << 1) | (lFSR[14] & 0xFFFF)
	bitReconstruction2(lFSR, x1, x2)
}

func bitReconstruction4(lFSR [16]uint32, x0 *uint32, x1 *uint32, x2 *uint32, x3 *uint32) {
	bitReconstruction3(lFSR, x0, x1, x2)
	*x3 = ((lFSR[2] & 0xFFFF) << 16) | (lFSR[0] >> 15)
}

func f_(r1 *uint32, r2 *uint32, u *uint32, v *uint32, x1 uint32, x2 uint32) {
	W1 := *r1 + x1
	W2 := *r2 ^ x2
	*u = l1((W1 << 16) | (W2 >> 16))
	*v = l2((W2 << 16) | (W1 >> 16))
	*r1 = makeU32(uint32(s0[(*u)>>24]), uint32(s1[((*u)>>16)&0xFF]), uint32(s0[((*u)>>8)&0xFF]), uint32(s1[(*u)&0xFF]))
	*r2 = makeU32(uint32(s0[(*v)>>24]), uint32(s1[((*v)>>16)&0xFF]), uint32(s0[((*v)>>8)&0xFF]), uint32(s1[(*v)&0xFF]))
}

func makeU32(a uint32, b uint32, c uint32, d uint32) uint32 {
	return ((a) << 24) | ((b) << 16) | ((c) << 8) | (d)
}

func l1(x uint32) uint32 {
	r := (x) ^ rot32(x, 2) ^ rot32(x, 10) ^ rot32(x, 18) ^ rot32(x, 24)
	return r
}

func l2(x uint32) uint32 {
	return (x) ^ rot32(x, 8) ^ rot32(x, 14) ^ rot32(x, 22) ^ rot32(x, 30)
}

func rot32(a uint32, k int) uint32 {
	return ((a) << (k)) | ((a) >> (32 - (k)))
}

func f(r1 *uint32, r2 *uint32, u *uint32, v *uint32, x0 uint32, x1 uint32, x2 uint32) uint32 {
	t := (x0 ^ *r1) + *r2
	f_(r1, r2, u, v, x1, x2)
	return t
}

func zuc256MakeU31(a uint32, b uint32, c uint32, d uint32) uint32 {
	return (a << 23) | (b << 16) | (c << 8) | d
}
